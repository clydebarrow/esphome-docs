``to_ntc_resistance``
*********************

Convert your sensor values available as temperature into corresponding
resistance values using an NTC characteristic curve.

Configuration variables:

- **calibration** (**Required**): calibration data.

A resistance/temperature characteristic curve is required to use this filter.
This can be taken from a corresponding diagram in a data sheet. If you do not
have access to the data sheet or want to calculate these values yourself, you
must first measure three resistance values at different temperatures.
Heat or cool the NTC to three different temperatures (preferably widely separated
temperatures) and note the resistance values at these temperatures.
Then enter these values in the calibration parameter:

.. code-block:: yaml

    - platform: template
      id: to_ntc_resistance_sensor1
      unit_of_measurement: "Ohm"
      lambda: |-
        return id(some_sensor).state;
      update_interval: 1s
      filters:
        - to_ntc_resistance:
            calibration:
              - 10.0kOhm -> 25°C
              - 27.219kOhm -> 0°C
              - 14.674kOhm -> 15°C

The filter determines coefficients for the `Steinhart-Hart`_ equation from the specified
pairs of values which can also be specified directly as an alternative.

.. _Steinhart-Hart: https://en.wikipedia.org/wiki/Steinhart%E2%80%93Hart_equation

.. code-block:: yaml

    - platform: template
      id: to_ntc_resistance_sensor2
      unit_of_measurement: "Ohm"
      lambda: |-
        return id(some_sensor).state;
      update_interval: 1s
      filters:
        - to_ntc_resistance:
            calibration:
              a: 1.439114856904070E-03
              b: 2.693066430764570E-04
              c: 1.653440958554570E-07

To send the resistance value generated by this sensor to an output component, e.g. a
digital potentiometer or a DAC, the sensor automation :ref:`sensor-on_value` can be used.
This makes it possible, for example, to replace a physical NTC and thus make it `smart`.

An output component can accept values in the range of `0..1` (see :ref:`output-set_level_action`),
so that scaling with the actual resistance value of the simulated NTC is required.

.. code-block:: yaml

    on_value:
      then:
        - output.set_level:
            id: output_id
            level: !lambda return x / 100000.0;

